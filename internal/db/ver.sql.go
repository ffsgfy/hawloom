// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ver.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createVer = `-- name: CreateVer :one
INSERT INTO ver (id, doc, vord_num, created_by, summary, content)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, doc, vord_num, votes, created_by, created_at, summary, content
`

type CreateVerParams struct {
	ID        uuid.UUID `db:"id"`
	Doc       uuid.UUID `db:"doc"`
	VordNum   int32     `db:"vord_num"`
	CreatedBy int32     `db:"created_by"`
	Summary   string    `db:"summary"`
	Content   string    `db:"content"`
}

func (q *Queries) CreateVer(ctx context.Context, arg *CreateVerParams) (*Ver, error) {
	row := q.db.QueryRow(ctx, createVer,
		arg.ID,
		arg.Doc,
		arg.VordNum,
		arg.CreatedBy,
		arg.Summary,
		arg.Content,
	)
	var i Ver
	err := row.Scan(
		&i.ID,
		&i.Doc,
		&i.VordNum,
		&i.Votes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Summary,
		&i.Content,
	)
	return &i, err
}

const deleteVer = `-- name: DeleteVer :exec
DELETE FROM ver WHERE id = $1
`

func (q *Queries) DeleteVer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVer, id)
	return err
}

const findVerForDelete = `-- name: FindVerForDelete :one
SELECT ver.vord_num, ver.created_by, ver.doc AS doc_id
FROM ver
    JOIN vord ON vord.doc = ver.doc AND vord.num = ver.vord_num
WHERE ver.id = $1
FOR SHARE OF vord
`

type FindVerForDeleteRow struct {
	VordNum   int32     `db:"vord_num"`
	CreatedBy int32     `db:"created_by"`
	DocID     uuid.UUID `db:"doc_id"`
}

func (q *Queries) FindVerForDelete(ctx context.Context, id uuid.UUID) (*FindVerForDeleteRow, error) {
	row := q.db.QueryRow(ctx, findVerForDelete, id)
	var i FindVerForDeleteRow
	err := row.Scan(&i.VordNum, &i.CreatedBy, &i.DocID)
	return &i, err
}

const findVerForVote = `-- name: FindVerForVote :one
SELECT ver.vord_num, ver.doc AS doc_id, doc.flags AS doc_flags,
    CAST(ver_vote.account IS NOT NULL AS BOOLEAN) AS ver_vote_exists,
    CAST(doc_vote.account IS NOT NULL AS BOOLEAN) AS doc_vote_exists
FROM ver
    JOIN doc ON doc.id = ver.doc
    JOIN vord ON vord.doc = ver.doc AND vord.num = ver.vord_num
    LEFT JOIN vote AS ver_vote
        ON ver_vote.ver = $1 AND ver_vote.account = $2
    LEFT JOIN vote AS doc_vote
        ON doc_vote.doc = ver.doc AND doc_vote.vord_num = ver.vord_num AND doc_vote.account = $2
WHERE ver.id = $1
LIMIT 1
FOR SHARE OF vord
`

type FindVerForVoteRow struct {
	VordNum       int32     `db:"vord_num"`
	DocID         uuid.UUID `db:"doc_id"`
	DocFlags      int32     `db:"doc_flags"`
	VerVoteExists bool      `db:"ver_vote_exists"`
	DocVoteExists bool      `db:"doc_vote_exists"`
}

func (q *Queries) FindVerForVote(ctx context.Context, ver uuid.UUID, account int32) (*FindVerForVoteRow, error) {
	row := q.db.QueryRow(ctx, findVerForVote, ver, account)
	var i FindVerForVoteRow
	err := row.Scan(
		&i.VordNum,
		&i.DocID,
		&i.DocFlags,
		&i.VerVoteExists,
		&i.DocVoteExists,
	)
	return &i, err
}

const findVersForCommit = `-- name: FindVersForCommit :many
SELECT id, votes FROM ver
WHERE doc = $1 AND vord_num = -1
ORDER BY votes DESC
LIMIT 2
`

type FindVersForCommitRow struct {
	ID    uuid.UUID `db:"id"`
	Votes int32     `db:"votes"`
}

// Assumes vord is locked
func (q *Queries) FindVersForCommit(ctx context.Context, doc uuid.UUID) ([]*FindVersForCommitRow, error) {
	rows, err := q.db.Query(ctx, findVersForCommit, doc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindVersForCommitRow
	for rows.Next() {
		var i FindVersForCommitRow
		if err := rows.Scan(&i.ID, &i.Votes); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVerVotes = `-- name: UpdateVerVotes :exec
UPDATE ver
SET votes = votes + $2
WHERE id = $1
`

// Assumes vord is locked
func (q *Queries) UpdateVerVotes(ctx context.Context, iD uuid.UUID, delta int32) error {
	_, err := q.db.Exec(ctx, updateVerVotes, iD, delta)
	return err
}
