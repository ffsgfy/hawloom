// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ver.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createVer = `-- name: CreateVer :one
INSERT INTO ver (id, doc, vord_num, created_by, summary, content)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, doc, vord_num, created_by, created_at, summary, content
`

type CreateVerParams struct {
	ID        uuid.UUID `db:"id"`
	Doc       uuid.UUID `db:"doc"`
	VordNum   int32     `db:"vord_num"`
	CreatedBy *int32    `db:"created_by"`
	Summary   string    `db:"summary"`
	Content   string    `db:"content"`
}

func (q *Queries) CreateVer(ctx context.Context, arg *CreateVerParams) (*Ver, error) {
	row := q.db.QueryRow(ctx, createVer,
		arg.ID,
		arg.Doc,
		arg.VordNum,
		arg.CreatedBy,
		arg.Summary,
		arg.Content,
	)
	var i Ver
	err := row.Scan(
		&i.ID,
		&i.Doc,
		&i.VordNum,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Summary,
		&i.Content,
	)
	return &i, err
}

const deleteVer = `-- name: DeleteVer :exec
DELETE FROM ver WHERE id = $1
`

func (q *Queries) DeleteVer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVer, id)
	return err
}

const findVerForDelete = `-- name: FindVerForDelete :one
SELECT ver.vord_num, ver.created_by, ver.doc AS doc_id FROM ver
WHERE ver.id = $1
FOR UPDATE
`

type FindVerForDeleteRow struct {
	VordNum   int32     `db:"vord_num"`
	CreatedBy *int32    `db:"created_by"`
	DocID     uuid.UUID `db:"doc_id"`
}

func (q *Queries) FindVerForDelete(ctx context.Context, id uuid.UUID) (*FindVerForDeleteRow, error) {
	row := q.db.QueryRow(ctx, findVerForDelete, id)
	var i FindVerForDeleteRow
	err := row.Scan(&i.VordNum, &i.CreatedBy, &i.DocID)
	return &i, err
}

const findVerForVote = `-- name: FindVerForVote :one
SELECT ver.vord_num, ver.created_by, ver.doc AS doc_id, doc.flags AS doc_flags,
    CAST(ver_vote.account IS NOT NULL AS BOOLEAN) AS ver_vote_exists,
    CAST(doc_vote.account IS NOT NULL AS BOOLEAN) AS doc_vote_exists
FROM ver
    JOIN doc ON doc.id = ver.doc
    LEFT JOIN vote AS ver_vote
        ON ver_vote.ver = $1 AND ver_vote.account = $2
    LEFT JOIN vote AS doc_vote
        ON doc_vote.doc = ver.doc AND doc_vote.vord_num = ver.vord_num AND doc_vote.account = $2
WHERE ver.id = $1
LIMIT 1
FOR SHARE OF ver
`

type FindVerForVoteParams struct {
	Ver     uuid.UUID `db:"ver"`
	Account int32     `db:"account"`
}

type FindVerForVoteRow struct {
	VordNum       int32     `db:"vord_num"`
	CreatedBy     *int32    `db:"created_by"`
	DocID         uuid.UUID `db:"doc_id"`
	DocFlags      int32     `db:"doc_flags"`
	VerVoteExists bool      `db:"ver_vote_exists"`
	DocVoteExists bool      `db:"doc_vote_exists"`
}

func (q *Queries) FindVerForVote(ctx context.Context, arg *FindVerForVoteParams) (*FindVerForVoteRow, error) {
	row := q.db.QueryRow(ctx, findVerForVote, arg.Ver, arg.Account)
	var i FindVerForVoteRow
	err := row.Scan(
		&i.VordNum,
		&i.CreatedBy,
		&i.DocID,
		&i.DocFlags,
		&i.VerVoteExists,
		&i.DocVoteExists,
	)
	return &i, err
}
