// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: ver.sql

package db

import (
	"context"

	"github.com/google/uuid"
)

const createVer = `-- name: CreateVer :one
INSERT INTO ver (id, doc, vord_num, created_by, summary, content)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, doc, vord_num, votes, created_by, created_at, summary, content
`

type CreateVerParams struct {
	ID        uuid.UUID `db:"id"`
	Doc       uuid.UUID `db:"doc"`
	VordNum   int32     `db:"vord_num"`
	CreatedBy int32     `db:"created_by"`
	Summary   string    `db:"summary"`
	Content   string    `db:"content"`
}

func (q *Queries) CreateVer(ctx context.Context, arg *CreateVerParams) (*Ver, error) {
	row := q.db.QueryRow(ctx, createVer,
		arg.ID,
		arg.Doc,
		arg.VordNum,
		arg.CreatedBy,
		arg.Summary,
		arg.Content,
	)
	var i Ver
	err := row.Scan(
		&i.ID,
		&i.Doc,
		&i.VordNum,
		&i.Votes,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.Summary,
		&i.Content,
	)
	return &i, err
}

const deleteVer = `-- name: DeleteVer :exec
DELETE FROM ver WHERE id = $1
`

func (q *Queries) DeleteVer(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteVer, id)
	return err
}

const findCurrentVer = `-- name: FindCurrentVer :one
SELECT ver.id, ver.doc, ver.vord_num, ver.votes, ver.created_by, ver.created_at, ver.summary, ver.content, ver_acc.name AS ver_author,
    doc.id, doc.title, doc.description, doc.flags, doc.created_by, doc.created_at, doc.vord_duration, doc_acc.name AS doc_author,
    vord.doc, vord.num, vord.flags, vord.start_at, vord.finish_at
FROM ver
    JOIN account AS ver_acc ON ver_acc.id = ver.created_by
    JOIN doc ON doc.id = ver.doc
    JOIN account AS doc_acc ON doc_acc.id = doc.created_by
    JOIN vord ON vord.doc = ver.doc AND vord.num = -1
WHERE ver.doc = $1
ORDER BY ver.vord_num DESC, ver.votes DESC
LIMIT 1
`

type FindCurrentVerRow struct {
	Ver       Ver    `db:"ver"`
	VerAuthor string `db:"ver_author"`
	Doc       Doc    `db:"doc"`
	DocAuthor string `db:"doc_author"`
	Vord      Vord   `db:"vord"`
}

func (q *Queries) FindCurrentVer(ctx context.Context, doc uuid.UUID) (*FindCurrentVerRow, error) {
	row := q.db.QueryRow(ctx, findCurrentVer, doc)
	var i FindCurrentVerRow
	err := row.Scan(
		&i.Ver.ID,
		&i.Ver.Doc,
		&i.Ver.VordNum,
		&i.Ver.Votes,
		&i.Ver.CreatedBy,
		&i.Ver.CreatedAt,
		&i.Ver.Summary,
		&i.Ver.Content,
		&i.VerAuthor,
		&i.Doc.ID,
		&i.Doc.Title,
		&i.Doc.Description,
		&i.Doc.Flags,
		&i.Doc.CreatedBy,
		&i.Doc.CreatedAt,
		&i.Doc.VordDuration,
		&i.DocAuthor,
		&i.Vord.Doc,
		&i.Vord.Num,
		&i.Vord.Flags,
		&i.Vord.StartAt,
		&i.Vord.FinishAt,
	)
	return &i, err
}

const findVer = `-- name: FindVer :one
SELECT ver.id, ver.doc, ver.vord_num, ver.votes, ver.created_by, ver.created_at, ver.summary, ver.content, account.name AS author
FROM ver
    JOIN account ON account.id = ver.created_by
WHERE ver.id = $1
`

type FindVerRow struct {
	Ver    Ver    `db:"ver"`
	Author string `db:"author"`
}

func (q *Queries) FindVer(ctx context.Context, id uuid.UUID) (*FindVerRow, error) {
	row := q.db.QueryRow(ctx, findVer, id)
	var i FindVerRow
	err := row.Scan(
		&i.Ver.ID,
		&i.Ver.Doc,
		&i.Ver.VordNum,
		&i.Ver.Votes,
		&i.Ver.CreatedBy,
		&i.Ver.CreatedAt,
		&i.Ver.Summary,
		&i.Ver.Content,
		&i.Author,
	)
	return &i, err
}

const findVerForDelete = `-- name: FindVerForDelete :one
SELECT ver.vord_num, ver.created_by, ver.doc AS doc_id
FROM ver
    JOIN vord ON vord.doc = ver.doc AND vord.num = ver.vord_num
WHERE ver.id = $1
FOR SHARE OF vord
`

type FindVerForDeleteRow struct {
	VordNum   int32     `db:"vord_num"`
	CreatedBy int32     `db:"created_by"`
	DocID     uuid.UUID `db:"doc_id"`
}

func (q *Queries) FindVerForDelete(ctx context.Context, id uuid.UUID) (*FindVerForDeleteRow, error) {
	row := q.db.QueryRow(ctx, findVerForDelete, id)
	var i FindVerForDeleteRow
	err := row.Scan(&i.VordNum, &i.CreatedBy, &i.DocID)
	return &i, err
}

const findVerForVote = `-- name: FindVerForVote :one
SELECT ver.vord_num, ver.doc AS doc_id, doc.flags AS doc_flags,
    CAST(ver_vote.account IS NOT NULL AS BOOLEAN) AS ver_vote_exists,
    CAST(doc_vote.account IS NOT NULL AS BOOLEAN) AS doc_vote_exists
FROM ver
    JOIN doc ON doc.id = ver.doc
    JOIN vord ON vord.doc = ver.doc AND vord.num = ver.vord_num
    LEFT JOIN vote AS ver_vote
        ON ver_vote.ver = $1 AND ver_vote.account = $2
    LEFT JOIN vote AS doc_vote
        ON doc_vote.doc = ver.doc AND doc_vote.vord_num = ver.vord_num AND doc_vote.account = $2
WHERE ver.id = $1
LIMIT 1
FOR SHARE OF vord
`

type FindVerForVoteRow struct {
	VordNum       int32     `db:"vord_num"`
	DocID         uuid.UUID `db:"doc_id"`
	DocFlags      int32     `db:"doc_flags"`
	VerVoteExists bool      `db:"ver_vote_exists"`
	DocVoteExists bool      `db:"doc_vote_exists"`
}

func (q *Queries) FindVerForVote(ctx context.Context, ver uuid.UUID, account int32) (*FindVerForVoteRow, error) {
	row := q.db.QueryRow(ctx, findVerForVote, ver, account)
	var i FindVerForVoteRow
	err := row.Scan(
		&i.VordNum,
		&i.DocID,
		&i.DocFlags,
		&i.VerVoteExists,
		&i.DocVoteExists,
	)
	return &i, err
}

const findVerList = `-- name: FindVerList :many
SELECT ver.id, ver.votes, account.name AS author, ver.summary
FROM ver
    JOIN account ON account.id = ver.created_by
WHERE ver.doc = $1 AND ver.vord_num = $2
ORDER BY ver.votes DESC
`

type FindVerListRow struct {
	ID      uuid.UUID `db:"id"`
	Votes   int32     `db:"votes"`
	Author  string    `db:"author"`
	Summary string    `db:"summary"`
}

func (q *Queries) FindVerList(ctx context.Context, doc uuid.UUID, vordNum int32) ([]*FindVerListRow, error) {
	rows, err := q.db.Query(ctx, findVerList, doc, vordNum)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindVerListRow
	for rows.Next() {
		var i FindVerListRow
		if err := rows.Scan(
			&i.ID,
			&i.Votes,
			&i.Author,
			&i.Summary,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findVerWithVote = `-- name: FindVerWithVote :one
SELECT ver.id, ver.doc, ver.vord_num, ver.votes, ver.created_by, ver.created_at, ver.summary, ver.content, account.name AS ver_author, doc.flags AS doc_flags,
    CAST(ver_vote.account IS NOT NULL AS BOOLEAN) AS ver_vote_exists,
    CAST(doc_vote.account IS NOT NULL AS BOOLEAN) AS doc_vote_exists
FROM ver
    JOIN account ON account.id = ver.created_by
    JOIN doc ON doc.id = ver.doc
    JOIN vord ON vord.doc = ver.doc AND vord.num = ver.vord_num
    LEFT JOIN vote AS ver_vote
        ON ver_vote.ver = $1 AND ver_vote.account = $2
    LEFT JOIN vote AS doc_vote
        ON doc_vote.doc = ver.doc AND doc_vote.vord_num = ver.vord_num AND doc_vote.account = $2
WHERE ver.id = $1
LIMIT 1
`

type FindVerWithVoteRow struct {
	Ver           Ver    `db:"ver"`
	VerAuthor     string `db:"ver_author"`
	DocFlags      int32  `db:"doc_flags"`
	VerVoteExists bool   `db:"ver_vote_exists"`
	DocVoteExists bool   `db:"doc_vote_exists"`
}

func (q *Queries) FindVerWithVote(ctx context.Context, ver uuid.UUID, account int32) (*FindVerWithVoteRow, error) {
	row := q.db.QueryRow(ctx, findVerWithVote, ver, account)
	var i FindVerWithVoteRow
	err := row.Scan(
		&i.Ver.ID,
		&i.Ver.Doc,
		&i.Ver.VordNum,
		&i.Ver.Votes,
		&i.Ver.CreatedBy,
		&i.Ver.CreatedAt,
		&i.Ver.Summary,
		&i.Ver.Content,
		&i.VerAuthor,
		&i.DocFlags,
		&i.VerVoteExists,
		&i.DocVoteExists,
	)
	return &i, err
}

const findVersForCommit = `-- name: FindVersForCommit :many
SELECT id, votes FROM ver
WHERE doc = $1 AND vord_num = -1
ORDER BY votes DESC
LIMIT 2
`

type FindVersForCommitRow struct {
	ID    uuid.UUID `db:"id"`
	Votes int32     `db:"votes"`
}

// Assumes vord is locked
func (q *Queries) FindVersForCommit(ctx context.Context, doc uuid.UUID) ([]*FindVersForCommitRow, error) {
	rows, err := q.db.Query(ctx, findVersForCommit, doc)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*FindVersForCommitRow
	for rows.Next() {
		var i FindVersForCommitRow
		if err := rows.Scan(&i.ID, &i.Votes); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const findWinningVer = `-- name: FindWinningVer :one
SELECT ver.id, ver.doc, ver.vord_num, ver.votes, ver.created_by, ver.created_at, ver.summary, ver.content, ver_acc.name AS ver_author,
    doc.id, doc.title, doc.description, doc.flags, doc.created_by, doc.created_at, doc.vord_duration, doc_acc.name AS doc_author,
    vord.doc, vord.num, vord.flags, vord.start_at, vord.finish_at
FROM ver
    JOIN account AS ver_acc ON ver_acc.id = ver.created_by
    JOIN doc ON doc.id = ver.doc
    JOIN account AS doc_acc ON doc_acc.id = doc.created_by
    JOIN vord ON vord.doc = ver.doc AND vord.num = $3
WHERE ver.doc = $1 AND ver.vord_num = $2
ORDER BY ver.votes DESC
LIMIT 1
`

type FindWinningVerParams struct {
	Doc         uuid.UUID `db:"doc"`
	VordNum     int32     `db:"vord_num"`
	VordNumJoin int32     `db:"vord_num_join"`
}

type FindWinningVerRow struct {
	Ver       Ver    `db:"ver"`
	VerAuthor string `db:"ver_author"`
	Doc       Doc    `db:"doc"`
	DocAuthor string `db:"doc_author"`
	Vord      Vord   `db:"vord"`
}

func (q *Queries) FindWinningVer(ctx context.Context, arg *FindWinningVerParams) (*FindWinningVerRow, error) {
	row := q.db.QueryRow(ctx, findWinningVer, arg.Doc, arg.VordNum, arg.VordNumJoin)
	var i FindWinningVerRow
	err := row.Scan(
		&i.Ver.ID,
		&i.Ver.Doc,
		&i.Ver.VordNum,
		&i.Ver.Votes,
		&i.Ver.CreatedBy,
		&i.Ver.CreatedAt,
		&i.Ver.Summary,
		&i.Ver.Content,
		&i.VerAuthor,
		&i.Doc.ID,
		&i.Doc.Title,
		&i.Doc.Description,
		&i.Doc.Flags,
		&i.Doc.CreatedBy,
		&i.Doc.CreatedAt,
		&i.Doc.VordDuration,
		&i.DocAuthor,
		&i.Vord.Doc,
		&i.Vord.Num,
		&i.Vord.Flags,
		&i.Vord.StartAt,
		&i.Vord.FinishAt,
	)
	return &i, err
}

const updateVerVotes = `-- name: UpdateVerVotes :exec
UPDATE ver
SET votes = votes + $2
WHERE id = $1
`

// Assumes vord is locked
func (q *Queries) UpdateVerVotes(ctx context.Context, iD uuid.UUID, delta int32) error {
	_, err := q.db.Exec(ctx, updateVerVotes, iD, delta)
	return err
}
